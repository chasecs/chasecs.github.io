<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail） - 编程札记 Programming Notes</title>
  <meta property="og:title" content="翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail） - 编程札记 Programming Notes" />
  <meta name="twitter:title" content="翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked …" />
  <meta name="description" content=" Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了加深印象，所以把原文翻译了一遍。">
  <meta property="og:description" content=" Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了加深印象，所以把原文翻译了一遍。">
  <meta name="twitter:description" content=" Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了 …">
  <meta name="author" content="ttimehc" />
  <meta property="og:site_name" content="编程札记 Programming Notes" />
  <meta property="og:url" content="https://example.com/posts/2017-10-07-simplified-chinese-translation-of-javascript-promises-in-wicked-detail/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.74.3" />

  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/js/fontawesome.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>

</head>
<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">编程札记 Programming Notes</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

<div class="main" role="main">
  <article class="article">
    
    
    <h1 class="article-title">翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail）</h1>
    
    <hr class="article-title-bottom">
    <ul class="article-meta">
      <li class="article-meta-date"><time>October 7, 2017</time>
      </li>
      <li class="article-meta-categories">
        <a href="/categories/javascript/">
          <i class="fas fa-folder"></i>
          javascript
        </a>&nbsp;
      </li>
    </ul>
    
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#更新日志">更新日志</a></li>
    <li><a href="#目录">目录</a></li>
    <li><a href="#为什么">为什么</a></li>
    <li><a href="#最简单的例子">最简单的例子</a>
      <ul>
        <li><a href="#a-name定义promise类型定义-promise-类型"><!-- raw HTML omitted -->定义 Promise 类型</a></li>
        <li><a href="#当前的代码既脆弱又不好">当前的代码既脆弱又不好</a></li>
      </ul>
    </li>
    <li><a href="#a-namepromises的状态promises-的状态"><!-- raw HTML omitted -->Promises 的状态</a></li>
    <li><a href="#a-name实现promises链-实现-promises链"><!-- raw HTML omitted -->实现 Promises链</a>
      <ul>
        <li><a href="#回调是可选项">回调是可选项</a></li>
        <li><a href="#a-name在promise链中返回promise-在-promise-链里返回-promise-类型"><!-- raw HTML omitted -->在 Promise 链里返回 Promise 类型</a></li>
      </ul>
    </li>
    <li><a href="#a-namepromises的reject-promises-的-reject"><!-- raw HTML omitted -->Promises 的 Reject</a>
      <ul>
        <li><a href="#a-name未知错误应该归纳到reject-未知错误应该归纳到-reject"><!-- raw HTML omitted -->未知错误应该归纳到 Reject</a></li>
        <li><a href="#a-namepromises可能会吃掉错误-promises-可能会吃掉错误"><!-- raw HTML omitted -->Promises 可能会“吃掉”错误</a></li>
        <li><a href="#a-name使用done来挽救-使用-done-来挽救"><!-- raw HTML omitted -->使用 <code>done()</code> 来挽救</a></li>
        <li><a href="#a-name从reject中挽救回来-从-reject-中挽救回来"><!-- raw HTML omitted -->从 Reject 中挽救回来</a></li>
      </ul>
    </li>
    <li><a href="#a-namepromise必须是异步的-promise-必须是异步的"><!-- raw HTML omitted -->Promise 必须是异步的</a>
      <ul>
        <li><a href="#a-name为什么promisesa规范要求异步-为什么-promisesa-规范要求异步"><!-- raw HTML omitted -->为什么 Promises/A+ 规范要求异步？</a></li>
      </ul>
    </li>
    <li><a href="#a-name准备封装thenpromise之前-准备封装-thenpromise-之前"><!-- raw HTML omitted -->准备封装 then/promise 之前</a></li>
    <li><a href="#结论">结论</a></li>
    <li><a href="#延伸阅读">延伸阅读</a></li>
    <li><a href="#翻译">翻译</a></li>
  </ul>
</nav>
</aside>
    <blockquote>
</blockquote>
<p><strong>译按：</strong>
<em>Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。</em><br>
<em>网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了加深印象，所以把原文翻译了一遍。</em></p>
<blockquote>
</blockquote>
<p><strong>原文：</strong> <a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/">JavaScript Promises &hellip; In Wicked Detail</a></p>
<blockquote>
</blockquote>
<p>我在自己的 JavaScript 代码里使用 promises 有一段时间了。刚开始使用的时候确实有些费解，但现在已经驾轻就熟。不过仔细想起来，我并不是完全明白它的原理。写这篇文章的目的就是为了弄明白它。如果你坚持看完这篇文章，你也能很好地理解 promise。</p>
<p>我们将渐进式地实现一个 promise，最终版本会基本符合 <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ 规范</a>，在这个过程中，你也会明白 promise 是怎样去满足异步编程的需求。本文假定你已经对 promises 有一定的了解。如果你还什么都不知道，可以先去 <a href="http://promisejs.org/">promisejs.org</a> 看看。</p>
<h2 id="更新日志">更新日志</h2>
<ul>
<li>2017-10-07 Added a fiddle to the <a href="#%E5%BD%93%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E6%97%A2%E8%84%86%E5%BC%B1%E5%8F%88%E4%B8%8D%E5%A5%BD">This Code is Brittle and Bad</a> section to demonstrate how it can fail.</li>
<li>2014-12-23: Added <a href="#%E4%BB%8EReject%E4%B8%AD%E6%8C%BD%E6%95%91%E5%9B%9E%E6%9D%A5">Recovering from Rejection</a> section. The article was a bit ambiguous on handling rejection, this new section should clear things up.</li>
</ul>
<h2 id="目录">目录</h2>
<ol>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88">为什么</a></li>
<li><a href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">最简单的例子</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89Promise%E7%B1%BB%E5%9E%8B">定义 Promise 类型</a></li>
<li><a href="#%E5%BD%93%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E6%97%A2%E8%84%86%E5%BC%B1%E5%8F%88%E4%B8%8D%E5%A5%BD">当前的代码既脆弱又不好</a></li>
</ul>
</li>
<li><a href="#Promises%E7%9A%84%E7%8A%B6%E6%80%81">Promises 的状态</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0Promises%E9%93%BE">实现 Promises 链</a>
<ul>
<li><a href="#%E5%9B%9E%E8%B0%83%E6%98%AF%E5%8F%AF%E9%80%89%E9%A1%B9">回调是可选项</a></li>
<li><a href="#%E5%9C%A8Promise%E9%93%BE%E4%B8%AD%E8%BF%94%E5%9B%9EPromise">在 Promise 链中返回 Promise</a></li>
</ul>
</li>
<li><a href="#Promises%E7%9A%84Reject">Promise 的 Reject</a>
<ul>
<li><a href="#%E6%9C%AA%E7%9F%A5%E9%94%99%E8%AF%AF%E4%B9%9F%E5%BA%94%E8%AF%A5%E5%BD%92%E7%BA%B3%E5%88%B0Reject">未知错误应该归纳到 Reject</a></li>
<li><a href="#Promises%E5%8F%AF%E8%83%BD%E4%BC%9A%E2%80%9C%E5%90%83%E6%8E%89%E2%80%9D%E9%94%99%E8%AF%AF">Promises 可能会“吃掉”错误</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8done%E6%9D%A5%E6%8C%BD%E6%95%91">使用 <code>done()</code> 来挽救</a></li>
<li><a href="#%E4%BB%8EReject%E4%B8%AD%E6%8C%BD%E6%95%91%E5%9B%9E%E6%9D%A5">从 Reject 中挽救回来</a></li>
</ul>
</li>
<li><a href="#Promise%E5%BF%85%E9%A1%BB%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84">Promise 必须是异步的</a></li>
</ol>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88Promises/A+%E8%A7%84%E8%8C%83%E8%A6%81%E6%B1%82%E5%BC%82%E6%AD%A5">为什么 Promises/A+ 规范要求异步</a></li>
</ul>
<ol start="7">
<li><a href="#%E5%87%86%E5%A4%87%E5%B0%81%E8%A3%85then/promise%E4%B9%8B%E5%89%8D">准备封装 then/promise 之前</a></li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li>
<li><a href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB">延伸阅读</a></li>
<li><a href="#%E7%BF%BB%E8%AF%91">翻译</a></li>
</ol>
<h2 id="为什么">为什么</h2>
<p>为什么要费心思去深入理解 promise 呢？弄清楚它的工作机制，你可以更好地运用它，并在出现问题的时候更好地排查故障。我写这篇文章的缘由，是有一回和同事被一个棘手的 promise 问题给难住了，如果我当时像现在这么熟悉 promise，就不会一筹莫展。</p>
<h2 id="最简单的例子">最简单的例子</h2>
<p>我们先实现一个最简单的 promise 。</p>
<p>我们要把这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got a value:&#39;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>改造成这样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got a value:&#39;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>为此，需要把 <code>doSomething()</code> 从：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="nx">callback</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>改成如下基于 &ldquo;promise&rdquo; 的方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">then</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/zdgrC/1/">fiddle</a></p>
<p>当前的做法仅仅是给回调模式（callback pattern）的加了一层糖衣，还没有什么实际作用。不过，我们才刚起步，而且也触及到了 promise 的核心思想。</p>
<blockquote>
<p>Promises 捕获一个概念上称作终值(eventual value)的东西，并把它保存到一个对象(object)</p>
</blockquote>
<p>这是为什么 promises 值得玩味的原因。如果“最终的东西”可以被捕获，我们就可以着手实现很强大的功能。我们将在稍后的文章中探讨此事。</p>
<h3 id="a-name定义promise类型定义-promise-类型"><!-- raw HTML omitted -->定义 Promise 类型</h3>
<p>上述代码只是返回了一个简单的对象。让我们定义一个真正的 Promise 类型，并以它为基础渐进扩展：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callback</span> <span class="o">=</span> <span class="nx">cb</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用这个 Promise 类型来实现 <code>doSomething()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当前的代码存在一个问题。如果你追溯整个执行的过程，你会发现 <code>resolve()</code> 会在 <code>then()</code> 之前被调用，这意味着此时的 <code>callback</code> 还是 null 。我们暂时先用 <code>setTimeout</code> 来处理这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callback</span> <span class="o">=</span> <span class="nx">cb</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// force callback to be called in the next
</span><span class="c1"></span>    <span class="c1">// iteration of the event loop, giving
</span><span class="c1"></span>    <span class="c1">// callback a chance to be set by then()
</span><span class="c1"></span>    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/uQrza/1/">fiddle</a></p>
<p>通过这个办法，这段代码还是可以运行的，虽然有些勉强。</p>
<h3 id="当前的代码既脆弱又不好">当前的代码既脆弱又不好</h3>
<p>目前这个简陋的 promise 实现版本，只能在同步执行的代码中运行（译注：原文用的词是 asynchronicity，个人认为是写错了，应该是synchronicity）。只要 <code>then()</code> 也是异步的，这段程序就会再次失败，<code>callback</code> 又会变成 null。为什么我要做这个错误的示例呢，那是因为这个实现版本的好处是浅显易懂，让你先了解个大概。<code>then()</code> 和 <code>resolve()</code> 下来也会继续保留着，它们是 promise 的核心概念。</p>
<p>下面这个例子能表明我的意思：</p>
<p><a href="http://jsfiddle.net/3kku32vp/">fiddle</a></p>
<p>*译注：START👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">()</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    	<span class="nx">log</span><span class="p">(</span><span class="s2">&#34;got a value&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
		<span class="p">});</span>
<span class="p">},</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">//setTimeout 延迟 `then()` 的调用，因此 promise 先执行，此时 promise 的 callback 还是 null
</span></code></pre></td></tr></table>
</div>
</div><p>*译注：END👆</p>
<p>如果你打开 console，你会发现一个错误提示：callback is not a function 。因为 <code>then()</code> 在 <code>setTimeout</code> 里调用.</p>
<h2 id="a-namepromises的状态promises-的状态"><!-- raw HTML omitted -->Promises 的状态</h2>
<p>上面那个不可靠的实现版本提醒我们，Promise 应该有状态标志。我们需要在程序执行前知道，当前处于哪种状态，并保证状态的正确地变更。这样程序才会变得健壮起来。</p>
<blockquote>
<ul>
<li>promise 等待一个值时，它的状态是 pending，获取一个值之后，状态是 resolved 。</li>
<li>当 promise resolve 一个值（value）之后，它会锁定那个值，不会再次 resolve。</li>
</ul>
</blockquote>
<p>（promise 还需要一个 rejected 的状态，用于处理发生错误的情况，我们稍后再涉及这方面的内容）</p>
<p>让我们在 promise 里加入状态标志，替换掉原来的暂行办法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">deferred</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;resolved&#39;</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">deferred</span> <span class="o">=</span> <span class="nx">onResolved</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">onResolved</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">handle</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/QX85J/1/">fiddle</a></p>
<p>虽然代码变得比原来复杂了，不过现在任何时候都可以调用 <code>then()</code>，<code>resolve()</code> 也可以在随时被调用，两者不必考虑谁先谁后。这样就可以同时支持同步和异步的代码。</p>
<p>这都是因为有了 state 这个标志，<code>then()</code> 和 <code>resolve()</code> 都把原来的工作交给了 <code>handle()</code>。<code>handle()</code> 将根据不同 state 作出以下处理：</p>
<ul>
<li>如果 <code>then()</code> 先于 <code>resolve()</code> 被调用，当前还没有 value 可以交付。在这种情况下，状态将是 pending，回调方法 <code>onResolved</code> 将被被暂时保存到 <code>deferred</code>。直到 <code>resolve()</code> 被调用后，再交付 value 并触发寄存在 <code>deferred</code> 的 <code>onResolved</code>。</li>
<li>如果 <code>resolve()</code> 先于 <code>then()</code> 被调用，value 会被保存下来，当 <code>then()</code> 被调用时，value 就可以交付了。</li>
</ul>
<p>注意到没有，现在已经不需要用到 <code>setTimeout</code> 了，不过这只是暂时的，等会儿还要再用到。</p>
<blockquote>
</blockquote>
<p>在 promises 里，并不讲究程序执行的先后次序，我们可以根据自己的需要决定先调用 <code>then()</code> 还是 <code>resolve()</code>。这也是“”捕获一个终值并保存到对象里”的强大之处。</p>
<blockquote>
</blockquote>
<p>按 Promises/A+ 规范，我们的 promises 还有不少要完善的地方，不过当前已经挺强大的了。我们可以多次调用 <code>then()</code>，每次都会得到相同的返回值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">();</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got a value:&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Got the same value again:&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>当然，对于目前的 promise 实现版本，这种说法也不完全是对的。可能会有相反的情况: 比如，在 <code>resolve()</code> 调用之前，多次调用 <code>then()</code>，只会成功兑现最后一次调用的 <code>then()</code>。对于这种情况有一个解决方案：把 promise 里所有的 deferreds 都保存在一个列表里，而不是像现在只保存在一个变量里。为了不让本文变得更复杂，我就不在这里实现这个特性。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<h2 id="a-name实现promises链-实现-promises链"><!-- raw HTML omitted -->实现 Promises链</h2>
<p>promise 可以异步地捕获一个概念并保存到对象里（capture the notion of asynchronicity in an object)，所以，我们可以
实现 promise 链，映射 promises，让它们依序或者平行地运行……以下的代码在 promise 中很常见：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">getSomeData</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">filterTheData</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">processTheData</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">displayTheData</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>getSomeData</code> 返回一个 promise，并调用 <code>then()</code>，而第一个 then 返回的，也必须是一个 promise，然后才可以不断地调用 <code>then()</code>。</p>
<blockquote>
<p><code>then()</code> 总是返回一个 promise</p>
</blockquote>
<p>实现了链的 promise ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">deferred</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;resolved&#39;</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">deferred</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">handler</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handler</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">handler</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handle</span><span class="p">({</span>
        <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span>
        <span class="nx">resolve</span><span class="o">:</span> <span class="nx">resolve</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/HdzLv/2/">fiddle</a></p>
<p>嗯，代码开始有点古怪了，你应该庆幸我们慢慢地构建这一切。这个环节最关键就是，<code>then()</code> 返回一个新的 promise 。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>由于 <code>then()</code> 总是会返回一个新的 promise 对象，这意味着至少有一个 promise 对象被创建(created)、处理(resolved)，最终却被无视(ignored)。这种情况也被视为一种浪费，回调模式就不存在这种问题。这是 promise 的一个弊端，想必现在你也能理解为什么 Javascript 圈子里有人会不喜欢 promise。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>那么，第二个 promise 的要 resolve 的值在哪里呢？它来自第一个 promise 的返回值，在 <code>handle()</code> 方法的最后部分实现。 <code>handler</code> 对象包含了一个 <code>onResolved</code> 回调方法和一个 <code>resolve()</code> 的引用（reference）。因为有不只一个 <code>resolve()</code> 方法，每个 promise 都会复制属于自身的 <code>resolve()</code> 方法，以及一个运行该方法的闭包。这也是从第一个 promise 过渡到第二个 promise 的桥梁。</p>
<p>我们把第一个 promise 归结到这行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个例子中，<code>handler.onResolved</code> 相当于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Got a value:&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>换句话说，先有一个 value 被传到第一个 <code>then()</code>，然后第一个 <code>handler</code> 的返回值则用于 resolve 第二个 promise 的值，这样就实现了 promise 链 ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;first result&#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">88</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">secondResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;second result&#39;</span><span class="p">,</span> <span class="nx">secondResult</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// the output is
</span><span class="c1">//
</span><span class="c1">// first result 42
</span><span class="c1">// second result 88
</span><span class="c1"></span>
<span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;first result&#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
  <span class="c1">// not explicitly returning anything
</span><span class="c1"></span><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">secondResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;second result&#39;</span><span class="p">,</span> <span class="nx">secondResult</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// now the output is
</span><span class="c1">//
</span><span class="c1">// first result 42
</span><span class="c1">// second result undefined
</span></code></pre></td></tr></table>
</div>
</div><p>因为 <code>then()</code> 总是会返回一个 promise，所以这个 promise 链可以无限延长：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;first result&#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">88</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">secondResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;second result&#39;</span><span class="p">,</span> <span class="nx">secondResult</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">99</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">thirdResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;third result&#39;</span><span class="p">,</span> <span class="nx">thirdResult</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fourthResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// on and on...
</span><span class="c1"></span><span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>假如在上述例子中，我们要在最后收集整个 promise 链的每一个返回值，该怎么办？利用这段 promise 链，我们可以自己构建返回的结果：</p>
<pre><code>doSomething().then(function(result) {
  var results = [result];
  results.push(88);
  return results;
}).then(function(results) {
  results.push(99);
  return results;
}).then(function(results) {
  console.log(results.join(',');
});
// the output is
//
// 42, 88, 99
</code></pre><blockquote>
</blockquote>
<p>Promises 只会 resolve 一个值 value 。如果你需要传递超过一个值，就需要把多个值改头换面包装起来（比如用数组、对象，合并字符串，等等）。</p>
<blockquote>
</blockquote>
<p>更好的办法是使用 promise 的 <code>all()</code> 方法，或者其它的工具方法，它们拓展了 promise 的可用性，下来也将会探讨这部分内容。</p>
<h3 id="回调是可选项">回调是可选项</h3>
<p><code>then()</code> 方法里的回调并不是必须的，如果你省略它，随后的 promise 会接着 resolve 上一个 promise 返回的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;got a result&#39;</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// the output is
</span><span class="c1">//
</span><span class="c1">// got a result 42
</span></code></pre></td></tr></table>
</div>
</div><p>个中原因可以在 <code>handle()</code>里发现，假如没有回调，它就会 resolve 上一个 promise 留下的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">handler</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">handler</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="a-name在promise链中返回promise-在-promise-链里返回-promise-类型"><!-- raw HTML omitted -->在 Promise 链里返回 Promise 类型</h3>
<p>当前的 promise 链还是有些初级，它只会机械地把 resolve 之后的值传递下去。假如其中一个被 resolve 的值是 promise ——就像下面这段代码——会出现什么情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// doSomethingElse returns a promise
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">finalResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;the final result is&#34;</span><span class="p">,</span> <span class="nx">finalResult</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>如代码执行的结果所示，<code>finalResult</code> 不是一个 resolve 之后的值，它是一个 promise，如果要得到预期的结构，需要这样修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// doSomethingElse returns a promise
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">anotherPromise</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">anotherPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">finalResult</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;the final result is&#34;</span><span class="p">,</span> <span class="nx">finalResult</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>但谁会希望代码这样乱糟糟的？再改进一下实现 promise 的代码，就可以优雅地处理这个问题。
在 <code>resolve()</code> 方法里增加一个判断条件，处理 promise 的情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">newValue</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">newValue</span><span class="p">.</span><span class="nx">then</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">newValue</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;resolved&#39;</span><span class="p">;</span>
  <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/38CCb/2/">fiddle</a></p>
<p>如果我们得到的返回值是一个 promise，就会循环地调用 <code>resolve()</code>。当返回值不是 promise 时，就像之前那样执行。</p>
<blockquote>
<blockquote>
<p>这里也有可能会出现无限循环的情况，Promises/A+ 规范建议实现 promise 时要检测无限循环的情况，但不是必须的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>还有需要指出的一点，这里上述判断返回值是否为 promise 的方法并不符合 Promises/A+ 规范，这篇文章的内容也没有完全符合 Promises/A+ 规范。如果你对这方面的内容感到好奇，建议你阅读这一节 <a href="https://promisesaplus.com/#the-promise-resolution-procedure">promise resolution procedure</a>.</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>需要注意的是，我们判断 <code>newValue</code> 是否为 promise 的方法是很宽松的，只判断返回值是否有一个 <code>then()</code> 方法。我这种 <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> 的做法其实是故意的，这样一来，不同的 promise 实现版本就可以协同使用（interopt）。实际上，不同 promise 库之前混用是很常见的，你在使用不同的第三方库时，它们也可能使用不同的 promise 实现方法。</p>
<blockquote>
<p>不同的 promise 实现方法可以协同使用（interopt），只要它们都恰如其分地遵照 Promises/A+ 规范</p>
</blockquote>
<p>实现了 promise 链之后，当前的版本已经相对比较完善了，但还缺少错误处理机制。</p>
<h2 id="a-namepromises的reject-promises-的-reject"><!-- raw HTML omitted -->Promises 的 Reject</h2>
<p>当 promise 执行过程中出现错误时，需要有一个原因来 reject 。我们可以在 <code>then()</code> 里传入第二个回调方法处理这一过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Success!&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Uh oh&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如先前所述，promise 的状态将从 pending 转变到 resolved 或 rejected 之一。因此，<code>then()</code> 的两个回调方法只有一个会被调用。</p>
</blockquote>
<p>Promises 通过 <code>reject()</code> 方法来实现拒绝，以下是实现了错误处理的 <code>doSomething()</code> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">somehowGetTheValue</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 promise 的实现方法里，我们也需要加入 reject ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">deferred</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">newValue</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">newValue</span><span class="p">.</span><span class="nx">then</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newValue</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;resolved&#39;</span><span class="p">;</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;rejected&#39;</span><span class="p">;</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="nx">reason</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">deferred</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">handlerCallback</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;resolved&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handlerCallback</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">onResolved</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">handlerCallback</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">onRejected</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">handlerCallback</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;resolved&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">handler</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">handler</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">handlerCallback</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">handler</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onResolved</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handle</span><span class="p">({</span>
        <span class="nx">onResolved</span><span class="o">:</span> <span class="nx">onResolved</span><span class="p">,</span>
        <span class="nx">onRejected</span><span class="o">:</span> <span class="nx">onRejected</span><span class="p">,</span>
        <span class="nx">resolve</span><span class="o">:</span> <span class="nx">resolve</span><span class="p">,</span>
        <span class="nx">reject</span><span class="o">:</span> <span class="nx">reject</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/rLXsL/2/">fiddle</a></p>
<p>除了增加了 <code>reject()</code> 方法，<code>handle()</code> 方法也要对 rejection 作出处理。在 <code>handle()</code> 方法里，将根据 <code>state</code> 的状态分别作出 reject 或 resolve 。而当前的 <code>state</code> 的也会被传递到下一个 promise ，下一个 promise 的 <code>resolve()</code> 或 <code>reject()</code> 方法同样也会改变它自身的 <code>state</code>。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>使用 promise 时，很容易忽略处理错误的回调，这样你就不会得到错误提示。至少你应该在你的最后一个 promise 里加上错误回调。关于这个问题你可以查看下文“ promise可能会‘吃掉’错误”一节的内容</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<h3 id="a-name未知错误应该归纳到reject-未知错误应该归纳到-reject"><!-- raw HTML omitted -->未知错误应该归纳到 Reject</h3>
<p>目前，我们的错误处理只针对已知错误。可能有未知的异常出现，就会导致程序崩溃，所以有必要在实现 promise 时对意外作出正确的 reject，即在 <code>resolve()</code> 方法里加入 <code>try/catch</code> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="c1">// ... as before
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此外，还得确保传入 <code>handle()</code> 回调方法也不会抛出异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... as before
</span><span class="c1"></span>
  <span class="kd">var</span> <span class="nx">ret</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">handlerCallback</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">handler</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">handler</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="a-namepromises可能会吃掉错误-promises-可能会吃掉错误"><!-- raw HTML omitted -->Promises 可能会“吃掉”错误</h3>
<blockquote>
<blockquote>
<p>promise 也有可能因为误解，导致错误被吃掉，很多人就被这种情况坑过。</p>
</blockquote>
</blockquote>
<p>请看以下例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">
<span class="kd">function</span> <span class="nx">getSomeJson</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">badJson</span> <span class="o">=</span> <span class="s2">&#34;&lt;div&gt;uh oh, this is not JSON at all!&lt;/div&gt;&#34;</span><span class="p">;</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">badJson</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nx">getSomeJson</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;uh oh&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="http://jsfiddle.net/city41/M7SRM/3/">fiddle</a></p>
<p>这段代码将会发生什么？<code>then()</code> 方法里的回调期望得到的是一个 JSON 对象，就天真地把结果当作 JSON 来解析，导致发生异常。虽然我们已经有了处理错误的回调，但管用吗？</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>实际上，错误回调并没有被调用，如果你在 fiddle 上运行这段代码，你不会得到任何输出，没有错误，什么都没有。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>为什么会出现这种情况？因为未处理的异常发生在 <code>then()</code> 的回调方法里，它是在 <code>handle()</code> 方法里被捕获的。这导致 <code>hande()</code> 方法 reject 了 <code>then()</code> 返回的 promise，而不是正在处理的 promise，整个过程就像 promise 被正确的 resolve 一样。</p>
<blockquote>
</blockquote>
<p>记住，在 <code>then()</code> 的回调里，你正在响应的 promise 已经被 resolve，所以你的回调方法对这个 promise 没有影响</p>
<blockquote>
</blockquote>
<p>如果你想捕获上面的那个错误，需要在下游加一个错误处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">getSomeJson</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;an error occured: &#34;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就可以打印处错误日志了。</p>
<blockquote>
<blockquote>
<p>按我的个人经验，这是 promise 最大的缺陷。下一节介绍了一个更好的办法——<code>done()</code>——来解决这个问题。</p>
</blockquote>
</blockquote>
<h3 id="a-name使用done来挽救-使用-done-来挽救"><!-- raw HTML omitted -->使用 <code>done()</code> 来挽救</h3>
<p>大部分（并非所有）promise 库都有一个 <code>done()</code> 方法。它和 <code>then()</code> 很像，并且没有上面提到的缺陷。</p>
<p>任何可以使用 <code>then()</code> 的地方，都可以使用 <code>done()</code>，它的主要不同点在于不会返回一个 promise，而且任何发生在 <code>done()</code> 发生的异常，不会被 promise 的实现机制捕获。换句话说，<code>done()</code> 表示整个 promise 链都被 resolve 了。上面 <code>getSomeJson()</code> 如果使用 <code> done()</code> 会更加健壮:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">getSomeJson</span><span class="p">().</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// when this throws, it won&#39;t be swallowed
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p><code>done()</code> 也可以增加一个处理错误的回调——<code>done(callback, errback)</code>，因为所有的 promise 都被 resovle 了，所以如果有异常发生，你也会得到通知。</p>
<blockquote>
<blockquote>
<p><code>done()</code> 不属于 Promises/A+ 规范（至少现在不是），所以你使用的 promise 库可能没有这个方法。</p>
</blockquote>
</blockquote>
<h3 id="a-name从reject中挽救回来-从-reject-中挽救回来"><!-- raw HTML omitted -->从 Reject 中挽救回来</h3>
<p>把一个被 reject 的 promise 挽救回来是有可能的。如果 <code>then()</code> 的错误回调被调用了，之后的 promise 就会以 resolve 来响应，而不是 reject ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">aMethodThatRejects</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// won&#39;t get here
</span><span class="c1"></span><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// since aMethodThatRejects calls reject()
</span><span class="c1"></span>  <span class="c1">// we end up here in the errback
</span><span class="c1"></span>  <span class="k">return</span> <span class="s2">&#34;recovered!&#34;</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;after recovery: &#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// we won&#39;t actually get here
</span><span class="c1"></span>  <span class="c1">// since the rejected promise had an errback
</span><span class="c1"></span><span class="p">});</span>

<span class="c1">// the output is
</span><span class="c1">// after recovery: recovered!
</span></code></pre></td></tr></table>
</div>
</div><p>如果 <code>then()</code> 没有传入处理错误的回调，reject 就会被传递到下一个 promise ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// notice the two calls to then()
</span><span class="c1"></span><span class="nx">aMethodThatRejects</span><span class="p">().</span><span class="nx">then</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// we won&#39;t get here
</span><span class="c1"></span><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;error propagated&#34;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// the output is
</span><span class="c1">// error propagated
</span></code></pre></td></tr></table>
</div>
</div><h2 id="a-namepromise必须是异步的-promise-必须是异步的"><!-- raw HTML omitted -->Promise 必须是异步的</h2>
<p>本文开始的时候，我们用到 <code>setTimeout</code>，但很快又移除了。
按 Promises/A+ 规范，promise 必须是异步的。要符合这个要求也不难，我们只要把 <code>handle()</code> 的主要代码封装在 <code>setTimeout</code> 里面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">deferred</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ... as before
</span><span class="c1"></span>  <span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上，真正的 promise 库并不倾向使用 <code>setTimeout</code>。如果是面向 NodeJS 的库，它倾向使用 <code>process.nextTick</code>，如果是针对浏览器的，可能用 <code>setImmediate</code> 或者 <a href="https://github.com/NobleJS/setImmediate">setImmediate shim</a> (目前只有 IE 支持 setImmediate)，又或者是 Kris Kowal 的异步工具库 <a href="https://github.com/kriskowal/asap">asap</a>（Kris Kowal 还写了 <a href="https://github.com/kriskowal/q">Q</a> ，一个很受欢迎的 promise 库）</p>
<h3 id="a-name为什么promisesa规范要求异步-为什么-promisesa-规范要求异步"><!-- raw HTML omitted -->为什么 Promises/A+ 规范要求异步？</h3>
<p>因为这样可以保证代码在执行过程保持一致，并且更加可靠，请看下面例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doAnOperation</span><span class="p">();</span>
<span class="nx">invokeSomething</span><span class="p">();</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">wrapItAllUp</span><span class="p">);</span>
<span class="nx">invokeSomethingElse</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码程序调用的流程是怎样的？从字面理解，你可能认为是 <code>invokeSomething()</code> -&gt; <code>invokeSomethingElse()</code> -&gt; <code>wrapItAllUp()</code>。实际上却是取决于 promise 的 resolve 是同步还是异步的。如果 <code>doAnOperation()</code> 是异步的，流程和预想的一样。但是，如果 <code>doAnOperation()</code> 是同步的，流程就会变成：<code>invokeSomething()</code> -&gt; <code>wrapItAllUp()</code> -&gt; <code>invokeSomethingElse()</code>，这样就不好了。</p>
<p>为了避开这种情况，promise 必须异步地 resolve，即使是你并不需要。这样会减少意外发生，别人在使用 promise 的时候也不用考虑同步还是异步。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>Promises always require at least one more iteration of the event loop to resolve. This is not necessarily true of the standard callback approach.</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<h2 id="a-name准备封装thenpromise之前-准备封装-thenpromise-之前"><!-- raw HTML omitted -->准备封装 then/promise 之前</h2>
<p>目前市面上已经有许多特性齐全的 promise 库。<a href="https://github.com/then">then</a> 组织的 promise 库是最简单的。它的目的就是，以最简省的方法实现一个符合 Promises/A+ 规范的 promise 库，如果你看看它的实现方法，会发现看起来很眼熟。</p>
<blockquote>
<blockquote>
<p>本文完成时，最终的 promise 版本看起来就很像 then/promise 的版本。以后可能就不像了，因为它们正推到重写 promise 实现方法。</p>
</blockquote>
</blockquote>
<p>本文的 promise 版本和实际的 promise 库有些不同，因为有许多 Promises/A+ 规范里的细节我并没有涉及。我建议阅读 Promises/A+ 规范，它很简短，而且通俗直白。</p>
<h2 id="结论">结论</h2>
<p>如果你看到这，真要谢谢你花时间的读下来了。我们已经触及到 promises 的核心，这也是Promises/A+ 规范唯一提及的内容。大部分的 promise 实现方法会提供更多功能，比如 <code>all()</code>, <code>spread()</code>, <code>race()</code>, <code>denodeify()</code> 等待。我建议阅读 [API docs for Bluebird] 了解更多关于 promise 的内容。</p>
<p>当我理解了 promise 的工作原理和注意事项后，我更喜欢它了，它让我的代码变得更加整洁、优雅。它还有许多可以谈论的话题，本文只是抛砖引玉。</p>
<h2 id="延伸阅读">延伸阅读</h2>
<p>更多关于 promises 的文章</p>
<ul>
<li><a href="promisejs.org">promisejs.org</a> – great tutorial on promises (already mentioned it a few times)</li>
<li>[Q’s Design Rationale](Q’s Design Rationale) – an article much like this one, but goes into even more detail. By Kris Kowal, creator of Q</li>
<li><a href="https://github.com/domenic/promises-unwrapping/issues/19">Some debate over whether done() is a good thing</a></li>
<li><a href="http://solutionoptimist.com/2013/12/27/javascript-promise-chains-2/">Flattening Promise Chains</a> by Thomas Burleson. A nice article that goes into more advanced usage of promises. If my article is the “what”, then Thomas’s is a nice look at the “why”.</li>
</ul>
<p><strong>Found a mistake?</strong> if I made an error and you want to let me know, please <a href="matt.e.greer@gmail.com">email me</a> or <a href="https://github.com/city41/blog/issues">file an issue</a>. Thanks!</p>
<h2 id="翻译">翻译</h2>
<ul>
<li><a href="http://p-baleine.hatenablog.com/entry/2014/03/12/190000">日文翻译</a>, translated by Junpei Tajima</li>
<li><a href="http://p-baleine.hatenablog.com/entry/2014/03/12/190000">繁体中文翻译</a>, translated by Jih-Chi Lee</li>
</ul>
  </article>

  


  
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'eb2224abc6c383a0371e',
        clientSecret: '054b7811c14e27f869e637afd14f6f380fa632c1',
        repo: 'chasecs.github.io',
        owner: 'chasecs',
        admin: ['chasecs'],
        id: decodeURI(location.pathname), 
        distractionFreeMode: false 
    });
    (function () {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
            return;
        }
        gitalk.render('gitalk-container');
    })();
</script>


  <ul class="pager article-pager">
    <li class="pager-newer">
      <a href="/posts/2019-07-28-password-hashing-md/" data-toggle="tooltip" data-placement="top"
        title="密码哈希(Password Hashing)">&lt; Newer</a>
    </li>
    <li class="pager-older">
      <a href="/posts/2017-09-28-how-to-build-private-repo-server-for-android-source-code/" data-toggle="tooltip" data-placement="top"
        title="搭建支持 Repo 的 Android 源码镜像（Repo 服务器）">Older &gt;</a>
    </li>
  </ul>
</div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2017 ttimehc@gmail.com</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-Github"><a href="http://github.com/chasecs" title="Github">Github</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>


</body>
</html>
