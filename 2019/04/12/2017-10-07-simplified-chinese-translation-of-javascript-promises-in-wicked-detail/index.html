<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了">
<meta property="og:type" content="article">
<meta property="og:title" content="翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail）">
<meta property="og:url" content="https://chasecs.github.io/2019/04/12/2017-10-07-simplified-chinese-translation-of-javascript-promises-in-wicked-detail/index.html">
<meta property="og:site_name" content="编程日志">
<meta property="og:description" content="Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-11T16:42:11.714Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail）">
<meta name="twitter:description" content="Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了">





  
  
  <link rel="canonical" href="https://chasecs.github.io/2019/04/12/2017-10-07-simplified-chinese-translation-of-javascript-promises-in-wicked-detail/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail） | 编程日志</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">编程日志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chasecs.github.io/2019/04/12/2017-10-07-simplified-chinese-translation-of-javascript-promises-in-wicked-detail/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ttimehc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编程日志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">翻译：JavaScript Promises 实现原理详解（JavaScript Promises ... In Wicked Detail）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-12 00:42:11" itemprop="dateCreated datePublished" datetime="2019-04-12T00:42:11+08:00">2019-04-12</time>
            

            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/12/2017-10-07-simplified-chinese-translation-of-javascript-promises-in-wicked-detail/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2019/04/12/2017-10-07-simplified-chinese-translation-of-javascript-promises-in-wicked-detail/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
            <div class="post-description"> Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了加深印象，所以把原文翻译了一遍。</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
</blockquote>
<p><strong>译按：</strong><br><em>Promise 是异步编程的一种解决方案，让 javascript 可以从杂乱回调函数中解脱出来。后来 ES6 标准把 Promise 纳入其中，原生提供了 Promise 对象。Promise 也成为 ES6 最主要的特性之一。</em><br><em>网上介绍 promise 使用方法的文章很多，解释其原理却很少。这篇文章循序渐进地实现了一遍 promise，分析透彻，对了解 promise 的工作原理很有帮助。为了加深印象，所以把原文翻译了一遍。</em></p>
<blockquote>
</blockquote>
<p><strong>原文：</strong> <a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/" target="_blank" rel="noopener">JavaScript Promises … In Wicked Detail</a></p>
<blockquote>
</blockquote>
<p>我在自己的 JavaScript 代码里使用 promises 有一段时间了。刚开始使用的时候确实有些费解，但现在已经驾轻就熟。不过仔细想起来，我并不是完全明白它的原理。写这篇文章的目的就是为了弄明白它。如果你坚持看完这篇文章，你也能很好地理解 promise。</p>
<p>我们将渐进式地实现一个 promise，最终版本会基本符合 <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="noopener">Promises/A+ 规范</a>，在这个过程中，你也会明白 promise 是怎样去满足异步编程的需求。本文假定你已经对 promises 有一定的了解。如果你还什么都不知道，可以先去 <a href="http://promisejs.org/" target="_blank" rel="noopener">promisejs.org</a> 看看。</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li>2017-10-07 Added a fiddle to the <a href="#当前的代码既脆弱又不好">This Code is Brittle and Bad</a> section to demonstrate how it can fail.</li>
<li>2014-12-23: Added <a href="#从Reject中挽救回来">Recovering from Rejection</a> section. The article was a bit ambiguous on handling rejection, this new section should clear things up.</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#为什么">为什么</a></li>
<li><a href="#最简单的例子">最简单的例子</a><ul>
<li><a href="#定义Promise类型">定义 Promise 类型</a></li>
<li><a href="#当前的代码既脆弱又不好">当前的代码既脆弱又不好</a></li>
</ul>
</li>
<li><a href="#Promises的状态">Promises 的状态</a></li>
<li><a href="#实现Promises链">实现 Promises 链</a><ul>
<li><a href="#回调是可选项">回调是可选项</a></li>
<li><a href="#在Promise链中返回Promise">在 Promise 链中返回 Promise</a></li>
</ul>
</li>
<li><a href="#Promises的Reject">Promise 的 Reject</a><ul>
<li><a href="#未知错误也应该归纳到Reject">未知错误应该归纳到 Reject</a></li>
<li><a href="#Promises可能会“吃掉”错误">Promises 可能会“吃掉”错误</a></li>
<li><a href="#使用done来挽救">使用 <code>done()</code> 来挽救</a></li>
<li><a href="#从Reject中挽救回来">从 Reject 中挽救回来</a></li>
</ul>
</li>
<li><a href="#Promise必须是异步的">Promise 必须是异步的</a><ul>
<li><a href="#为什么Promises/A+规范要求异步">为什么 Promises/A+ 规范要求异步</a></li>
</ul>
</li>
<li><a href="#准备封装then/promise之前">准备封装 then/promise 之前</a></li>
<li><a href="#结论">结论</a></li>
<li><a href="#延伸阅读">延伸阅读</a></li>
<li><a href="#翻译">翻译</a></li>
</ol>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么要费心思去深入理解 promise 呢？弄清楚它的工作机制，你可以更好地运用它，并在出现问题的时候更好地排查故障。我写这篇文章的缘由，是有一回和同事被一个棘手的 promise 问题给难住了，如果我当时像现在这么熟悉 promise，就不会一筹莫展。</p>
<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>我们先实现一个最简单的 promise 。</p>
<p>我们要把这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>改造成这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>为此，需要把 <code>doSomething()</code> 从：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">42</span>;</span><br><span class="line">  callback(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成如下基于 “promise” 的方案：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="number">42</span>;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/zdgrC/1/" target="_blank" rel="noopener">fiddle</a></p>
<p>当前的做法仅仅是给回调模式（callback pattern）的加了一层糖衣，还没有什么实际作用。不过，我们才刚起步，而且也触及到了 promise 的核心思想。</p>
<blockquote>
<p>Promises 捕获一个概念上称作终值(eventual value)的东西，并把它保存到一个对象(object)</p>
</blockquote>
<p>这是为什么 promises 值得玩味的原因。如果“最终的东西”可以被捕获，我们就可以着手实现很强大的功能。我们将在稍后的文章中探讨此事。</p>
<h3 id="定义-Promise-类型"><a href="#定义-Promise-类型" class="headerlink" title="定义 Promise 类型"></a><a name="定义Promise类型">定义 Promise 类型</a></h3><p>上述代码只是返回了一个简单的对象。让我们定义一个真正的 Promise 类型，并以它为基础渐进扩展：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    callback(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这个 Promise 类型来实现 <code>doSomething()</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">42</span>;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前的代码存在一个问题。如果你追溯整个执行的过程，你会发现 <code>resolve()</code> 会在 <code>then()</code> 之前被调用，这意味着此时的 <code>callback</code> 还是 null 。我们暂时先用 <code>setTimeout</code> 来处理这个问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// force callback to be called in the next</span></span><br><span class="line">    <span class="comment">// iteration of the event loop, giving</span></span><br><span class="line">    <span class="comment">// callback a chance to be set by then()</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/uQrza/1/" target="_blank" rel="noopener">fiddle</a></p>
<p>通过这个办法，这段代码还是可以运行的，虽然有些勉强。</p>
<h3 id="当前的代码既脆弱又不好"><a href="#当前的代码既脆弱又不好" class="headerlink" title="当前的代码既脆弱又不好"></a>当前的代码既脆弱又不好</h3><p>目前这个简陋的 promise 实现版本，只能在同步执行的代码中运行（译注：原文用的词是 asynchronicity，个人认为是写错了，应该是synchronicity）。只要 <code>then()</code> 也是异步的，这段程序就会再次失败，<code>callback</code> 又会变成 null。为什么我要做这个错误的示例呢，那是因为这个实现版本的好处是浅显易懂，让你先了解个大概。<code>then()</code> 和 <code>resolve()</code> 下来也会继续保留着，它们是 promise 的核心概念。</p>
<p>下面这个例子能表明我的意思：</p>
<p><a href="http://jsfiddle.net/3kku32vp/" target="_blank" rel="noopener">fiddle</a></p>
<p>*译注：START👇<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = doSomething()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    	log(<span class="string">"got a value"</span>, value);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTimeout 延迟 `then()` 的调用，因此 promise 先执行，此时 promise 的 callback 还是 null</span></span><br></pre></td></tr></table></figure></p>
<p>*译注：END👆</p>
<p>如果你打开 console，你会发现一个错误提示：callback is not a function 。因为 <code>then()</code> 在 <code>setTimeout</code> 里调用.</p>
<h2 id="Promises-的状态"><a href="#Promises-的状态" class="headerlink" title="Promises 的状态"></a><a name="Promises的状态">Promises 的状态</a></h2><p>上面那个不可靠的实现版本提醒我们，Promise 应该有状态标志。我们需要在程序执行前知道，当前处于哪种状态，并保证状态的正确地变更。这样程序才会变得健壮起来。</p>
<blockquote>
<ul>
<li>promise 等待一个值时，它的状态是 pending，获取一个值之后，状态是 resolved 。</li>
<li>当 promise resolve 一个值（value）之后，它会锁定那个值，不会再次 resolve。</li>
</ul>
</blockquote>
<p>（promise 还需要一个 rejected 的状态，用于处理发生错误的情况，我们稍后再涉及这方面的内容）</p>
<p>让我们在 promise 里加入状态标志，替换掉原来的暂行办法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> deferred;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">'resolved'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferred = onResolved;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onResolved(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">    handle(onResolved);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/QX85J/1/" target="_blank" rel="noopener">fiddle</a></p>
<p>虽然代码变得比原来复杂了，不过现在任何时候都可以调用 <code>then()</code>，<code>resolve()</code> 也可以在随时被调用，两者不必考虑谁先谁后。这样就可以同时支持同步和异步的代码。</p>
<p>这都是因为有了 state 这个标志，<code>then()</code> 和 <code>resolve()</code> 都把原来的工作交给了 <code>handle()</code>。<code>handle()</code> 将根据不同 state 作出以下处理：</p>
<ul>
<li>如果 <code>then()</code> 先于 <code>resolve()</code> 被调用，当前还没有 value 可以交付。在这种情况下，状态将是 pending，回调方法 <code>onResolved</code> 将被被暂时保存到 <code>deferred</code>。直到 <code>resolve()</code> 被调用后，再交付 value 并触发寄存在 <code>deferred</code> 的 <code>onResolved</code>。</li>
<li>如果 <code>resolve()</code> 先于 <code>then()</code> 被调用，value 会被保存下来，当 <code>then()</code> 被调用时，value 就可以交付了。</li>
</ul>
<p>注意到没有，现在已经不需要用到 <code>setTimeout</code> 了，不过这只是暂时的，等会儿还要再用到。</p>
<blockquote>
</blockquote>
<p>在 promises 里，并不讲究程序执行的先后次序，我们可以根据自己的需要决定先调用 <code>then()</code> 还是 <code>resolve()</code>。这也是“”捕获一个终值并保存到对象里”的强大之处。</p>
<blockquote>
</blockquote>
<p>按 Promises/A+ 规范，我们的 promises 还有不少要完善的地方，不过当前已经挺强大的了。我们可以多次调用 <code>then()</code>，每次都会得到相同的返回值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = doSomething();</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a value:'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got the same value again:'</span>, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
</blockquote>
<p>当然，对于目前的 promise 实现版本，这种说法也不完全是对的。可能会有相反的情况: 比如，在 <code>resolve()</code> 调用之前，多次调用 <code>then()</code>，只会成功兑现最后一次调用的 <code>then()</code>。对于这种情况有一个解决方案：把 promise 里所有的 deferreds 都保存在一个列表里，而不是像现在只保存在一个变量里。为了不让本文变得更复杂，我就不在这里实现这个特性。</p>
<blockquote>
</blockquote>
</blockquote>
<h2 id="实现-Promises链"><a href="#实现-Promises链" class="headerlink" title="实现 Promises链"></a><a name="实现Promises链">实现 Promises链</a></h2><p>promise 可以异步地捕获一个概念并保存到对象里（capture the notion of asynchronicity in an object)，所以，我们可以<br>实现 promise 链，映射 promises，让它们依序或者平行地运行……以下的代码在 promise 中很常见：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getSomeData()</span><br><span class="line">.then(filterTheData)</span><br><span class="line">.then(processTheData)</span><br><span class="line">.then(displayTheData);</span><br></pre></td></tr></table></figure></p>
<p><code>getSomeData</code> 返回一个 promise，并调用 <code>then()</code>，而第一个 then 返回的，也必须是一个 promise，然后才可以不断地调用 <code>then()</code>。</p>
<blockquote>
<p><code>then()</code> 总是返回一个 promise</p>
</blockquote>
<p>实现了链的 promise ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">'resolved'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferred = handler;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!handler.onResolved) &#123;</span><br><span class="line">      handler.resolve(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret = handler.onResolved(value);</span><br><span class="line">    handler.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onResolved: onResolved,</span><br><span class="line">        resolve: resolve</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/HdzLv/2/" target="_blank" rel="noopener">fiddle</a></p>
<p>嗯，代码开始有点古怪了，你应该庆幸我们慢慢地构建这一切。这个环节最关键就是，<code>then()</code> 返回一个新的 promise 。</p>
<blockquote>
<blockquote>
</blockquote>
<p>由于 <code>then()</code> 总是会返回一个新的 promise 对象，这意味着至少有一个 promise 对象被创建(created)、处理(resolved)，最终却被无视(ignored)。这种情况也被视为一种浪费，回调模式就不存在这种问题。这是 promise 的一个弊端，想必现在你也能理解为什么 Javascript 圈子里有人会不喜欢 promise。</p>
<blockquote>
</blockquote>
</blockquote>
<p>那么，第二个 promise 的要 resolve 的值在哪里呢？它来自第一个 promise 的返回值，在 <code>handle()</code> 方法的最后部分实现。 <code>handler</code> 对象包含了一个 <code>onResolved</code> 回调方法和一个 <code>resolve()</code> 的引用（reference）。因为有不只一个 <code>resolve()</code> 方法，每个 promise 都会复制属于自身的 <code>resolve()</code> 方法，以及一个运行该方法的闭包。这也是从第一个 promise 过渡到第二个 promise 的桥梁。</p>
<p>我们把第一个 promise 归结到这行代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = handler.onResolved(value);</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>handler.onResolved</code> 相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Got a value:"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>换句话说，先有一个 value 被传到第一个 <code>then()</code>，然后第一个 <code>handler</code> 的返回值则用于 resolve 第二个 promise 的值，这样就实现了 promise 链 ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first result'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">88</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">secondResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second result'</span>, secondResult);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the output is</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// first result 42</span></span><br><span class="line"><span class="comment">// second result 88</span></span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first result'</span>, result);</span><br><span class="line">  <span class="comment">// not explicitly returning anything</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">secondResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second result'</span>, secondResult);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now the output is</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// first result 42</span></span><br><span class="line"><span class="comment">// second result undefined</span></span><br></pre></td></tr></table></figure></p>
<p>因为 <code>then()</code> 总是会返回一个 promise，所以这个 promise 链可以无限延长：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first result'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">88</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">secondResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second result'</span>, secondResult);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">thirdResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'third result'</span>, thirdResult);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">fourthResult</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// on and on...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>假如在上述例子中，我们要在最后收集整个 promise 链的每一个返回值，该怎么办？利用这段 promise 链，我们可以自己构建返回的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function(result) &#123;</span><br><span class="line">  var results = [result];</span><br><span class="line">  results.push(88);</span><br><span class="line">  return results;</span><br><span class="line">&#125;).then(function(results) &#123;</span><br><span class="line">  results.push(99);</span><br><span class="line">  return results;</span><br><span class="line">&#125;).then(function(results) &#123;</span><br><span class="line">  console.log(results.join(&apos;,&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// the output is</span><br><span class="line">//</span><br><span class="line">// 42, 88, 99</span><br></pre></td></tr></table></figure></p>
<blockquote>
</blockquote>
<p>Promises 只会 resolve 一个值 value 。如果你需要传递超过一个值，就需要把多个值改头换面包装起来（比如用数组、对象，合并字符串，等等）。</p>
<blockquote>
</blockquote>
<p>更好的办法是使用 promise 的 <code>all()</code> 方法，或者其它的工具方法，它们拓展了 promise 的可用性，下来也将会探讨这部分内容。</p>
<h3 id="回调是可选项"><a href="#回调是可选项" class="headerlink" title="回调是可选项"></a>回调是可选项</h3><p><code>then()</code> 方法里的回调并不是必须的，如果你省略它，随后的 promise 会接着 resolve 上一个 promise 返回的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got a result'</span>, result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the output is</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// got a result 42</span></span><br></pre></td></tr></table></figure></p>
<p>个中原因可以在 <code>handle()</code>里发现，假如没有回调，它就会 resolve 上一个 promise 留下的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!handler.onResolved) &#123;</span><br><span class="line">  handler.resolve(value);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在-Promise-链里返回-Promise-类型"><a href="#在-Promise-链里返回-Promise-类型" class="headerlink" title="在 Promise 链里返回 Promise 类型"></a><a name="在Promise链中返回Promise">在 Promise 链里返回 Promise 类型</a></h3><p>当前的 promise 链还是有些初级，它只会机械地把 resolve 之后的值传递下去。假如其中一个被 resolve 的值是 promise ——就像下面这段代码——会出现什么情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// doSomethingElse returns a promise</span></span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"the final result is"</span>, finalResult);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如代码执行的结果所示，<code>finalResult</code> 不是一个 resolve 之后的值，它是一个 promise，如果要得到预期的结构，需要这样修改：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// doSomethingElse returns a promise</span></span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">anotherPromise</span>) </span>&#123;</span><br><span class="line">  anotherPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"the final result is"</span>, finalResult);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但谁会希望代码这样乱糟糟的？再改进一下实现 promise 的代码，就可以优雅地处理这个问题。<br>在 <code>resolve()</code> 方法里增加一个判断条件，处理 promise 的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(newValue &amp;&amp; <span class="keyword">typeof</span> newValue.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">    newValue.then(resolve);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  state = <span class="string">'resolved'</span>;</span><br><span class="line">  value = newValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">    handle(deferred);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/38CCb/2/" target="_blank" rel="noopener">fiddle</a></p>
<p>如果我们得到的返回值是一个 promise，就会循环地调用 <code>resolve()</code>。当返回值不是 promise 时，就像之前那样执行。</p>
<blockquote>
<blockquote>
<p>这里也有可能会出现无限循环的情况，Promises/A+ 规范建议实现 promise 时要检测无限循环的情况，但不是必须的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>还有需要指出的一点，这里上述判断返回值是否为 promise 的方法并不符合 Promises/A+ 规范，这篇文章的内容也没有完全符合 Promises/A+ 规范。如果你对这方面的内容感到好奇，建议你阅读这一节 <a href="https://promisesaplus.com/#the-promise-resolution-procedure" target="_blank" rel="noopener">promise resolution procedure</a>.</p>
<blockquote>
</blockquote>
</blockquote>
<p>需要注意的是，我们判断 <code>newValue</code> 是否为 promise 的方法是很宽松的，只判断返回值是否有一个 <code>then()</code> 方法。我这种 <a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">duck typing</a> 的做法其实是故意的，这样一来，不同的 promise 实现版本就可以协同使用（interopt）。实际上，不同 promise 库之前混用是很常见的，你在使用不同的第三方库时，它们也可能使用不同的 promise 实现方法。</p>
<blockquote>
<p>不同的 promise 实现方法可以协同使用（interopt），只要它们都恰如其分地遵照 Promises/A+ 规范</p>
</blockquote>
<p>实现了 promise 链之后，当前的版本已经相对比较完善了，但还缺少错误处理机制。</p>
<h2 id="Promises-的-Reject"><a href="#Promises-的-Reject" class="headerlink" title="Promises 的 Reject"></a><a name="Promises的Reject">Promises 的 Reject</a></h2><p>当 promise 执行过程中出现错误时，需要有一个原因来 reject 。我们可以在 <code>then()</code> 里传入第二个回调方法处理这一过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Success!'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Uh oh'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如先前所述，promise 的状态将从 pending 转变到 resolved 或 rejected 之一。因此，<code>then()</code> 的两个回调方法只有一个会被调用。</p>
</blockquote>
<p>Promises 通过 <code>reject()</code> 方法来实现拒绝，以下是实现了错误处理的 <code>doSomething()</code> ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = somehowGetTheValue();</span><br><span class="line">    <span class="keyword">if</span>(result.error) &#123;</span><br><span class="line">      reject(result.error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(result.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 promise 的实现方法里，我们也需要加入 reject ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(newValue &amp;&amp; <span class="keyword">typeof</span> newValue.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">      newValue.then(resolve, reject);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="string">'resolved'</span>;</span><br><span class="line">    value = newValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    state = <span class="string">'rejected'</span>;</span><br><span class="line">    value = reason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(deferred) &#123;</span><br><span class="line">      handle(deferred);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      deferred = handler;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handlerCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(state === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">      handlerCallback = handler.onResolved;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerCallback = handler.onRejected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!handlerCallback) &#123;</span><br><span class="line">      <span class="keyword">if</span>(state === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">        handler.resolve(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.reject(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret = handlerCallback(value);</span><br><span class="line">    handler.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onResolved: onResolved,</span><br><span class="line">        onRejected: onRejected,</span><br><span class="line">        resolve: resolve,</span><br><span class="line">        reject: reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/rLXsL/2/" target="_blank" rel="noopener">fiddle</a></p>
<p>除了增加了 <code>reject()</code> 方法，<code>handle()</code> 方法也要对 rejection 作出处理。在 <code>handle()</code> 方法里，将根据 <code>state</code> 的状态分别作出 reject 或 resolve 。而当前的 <code>state</code> 的也会被传递到下一个 promise ，下一个 promise 的 <code>resolve()</code> 或 <code>reject()</code> 方法同样也会改变它自身的 <code>state</code>。</p>
<blockquote>
<blockquote>
</blockquote>
<p>使用 promise 时，很容易忽略处理错误的回调，这样你就不会得到错误提示。至少你应该在你的最后一个 promise 里加上错误回调。关于这个问题你可以查看下文“ promise可能会‘吃掉’错误”一节的内容</p>
<blockquote>
</blockquote>
</blockquote>
<h3 id="未知错误应该归纳到-Reject"><a href="#未知错误应该归纳到-Reject" class="headerlink" title="未知错误应该归纳到 Reject"></a><a name="未知错误应该归纳到Reject">未知错误应该归纳到 Reject</a></h3><p>目前，我们的错误处理只针对已知错误。可能有未知的异常出现，就会导致程序崩溃，所以有必要在实现 promise 时对意外作出正确的 reject，即在 <code>resolve()</code> 方法里加入 <code>try/catch</code> ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... as before</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，还得确保传入 <code>handle()</code> 回调方法也不会抛出异常：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... as before</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ret = handlerCallback(value);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    handler.reject(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handler.resolve(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Promises-可能会“吃掉”错误"><a href="#Promises-可能会“吃掉”错误" class="headerlink" title="Promises 可能会“吃掉”错误"></a><a name="Promises可能会“吃掉”错误">Promises 可能会“吃掉”错误</a></h3><blockquote>
<blockquote>
<p>promise 也有可能因为误解，导致错误被吃掉，很多人就被这种情况坑过。</p>
</blockquote>
</blockquote>
<p>请看以下例子：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomeJson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> badJson = <span class="string">"&lt;div&gt;uh oh, this is not JSON at all!&lt;/div&gt;"</span>;</span><br><span class="line">    resolve(badJson);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getSomeJson().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'uh oh'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsfiddle.net/city41/M7SRM/3/" target="_blank" rel="noopener">fiddle</a></p>
<p>这段代码将会发生什么？<code>then()</code> 方法里的回调期望得到的是一个 JSON 对象，就天真地把结果当作 JSON 来解析，导致发生异常。虽然我们已经有了处理错误的回调，但管用吗？</p>
<blockquote>
<blockquote>
</blockquote>
<p>实际上，错误回调并没有被调用，如果你在 fiddle 上运行这段代码，你不会得到任何输出，没有错误，什么都没有。</p>
<blockquote>
</blockquote>
</blockquote>
<p>为什么会出现这种情况？因为未处理的异常发生在 <code>then()</code> 的回调方法里，它是在 <code>handle()</code> 方法里被捕获的。这导致 <code>hande()</code> 方法 reject 了 <code>then()</code> 返回的 promise，而不是正在处理的 promise，整个过程就像 promise 被正确的 resolve 一样。</p>
<blockquote>
</blockquote>
<p>记住，在 <code>then()</code> 的回调里，你正在响应的 promise 已经被 resolve，所以你的回调方法对这个 promise 没有影响</p>
<blockquote>
</blockquote>
<p>如果你想捕获上面的那个错误，需要在下游加一个错误处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getSomeJson().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;).then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"an error occured: "</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样就可以打印处错误日志了。</p>
<blockquote>
<blockquote>
<p>按我的个人经验，这是 promise 最大的缺陷。下一节介绍了一个更好的办法——<code>done()</code>——来解决这个问题。</p>
</blockquote>
</blockquote>
<h3 id="使用-done-来挽救"><a href="#使用-done-来挽救" class="headerlink" title="使用 done() 来挽救"></a><a name="使用done来挽救">使用 <code>done()</code> 来挽救</a></h3><p>大部分（并非所有）promise 库都有一个 <code>done()</code> 方法。它和 <code>then()</code> 很像，并且没有上面提到的缺陷。</p>
<p>任何可以使用 <code>then()</code> 的地方，都可以使用 <code>done()</code>，它的主要不同点在于不会返回一个 promise，而且任何发生在 <code>done()</code> 发生的异常，不会被 promise 的实现机制捕获。换句话说，<code>done()</code> 表示整个 promise 链都被 resolve 了。上面 <code>getSomeJson()</code> 如果使用 <code>done()</code> 会更加健壮:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSomeJson().done(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// when this throws, it won't be swallowed</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>done()</code> 也可以增加一个处理错误的回调——<code>done(callback, errback)</code>，因为所有的 promise 都被 resovle 了，所以如果有异常发生，你也会得到通知。</p>
<blockquote>
<blockquote>
<p><code>done()</code> 不属于 Promises/A+ 规范（至少现在不是），所以你使用的 promise 库可能没有这个方法。</p>
</blockquote>
</blockquote>
<h3 id="从-Reject-中挽救回来"><a href="#从-Reject-中挽救回来" class="headerlink" title="从 Reject 中挽救回来"></a><a name="从Reject中挽救回来">从 Reject 中挽救回来</a></h3><p>把一个被 reject 的 promise 挽救回来是有可能的。如果 <code>then()</code> 的错误回调被调用了，之后的 promise 就会以 resolve 来响应，而不是 reject ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">aMethodThatRejects().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// won't get here</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// since aMethodThatRejects calls reject()</span></span><br><span class="line">  <span class="comment">// we end up here in the errback</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"recovered!"</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"after recovery: "</span>, result);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// we won't actually get here</span></span><br><span class="line">  <span class="comment">// since the rejected promise had an errback</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the output is</span></span><br><span class="line"><span class="comment">// after recovery: recovered!</span></span><br></pre></td></tr></table></figure></p>
<p>如果 <code>then()</code> 没有传入处理错误的回调，reject 就会被传递到下一个 promise ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notice the two calls to then()</span></span><br><span class="line">aMethodThatRejects().then().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// we won't get here</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"error propagated"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the output is</span></span><br><span class="line"><span class="comment">// error propagated</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Promise-必须是异步的"><a href="#Promise-必须是异步的" class="headerlink" title="Promise 必须是异步的"></a><a name="Promise必须是异步的">Promise 必须是异步的</a></h2><p>本文开始的时候，我们用到 <code>setTimeout</code>，但很快又移除了。<br>按 Promises/A+ 规范，promise 必须是异步的。要符合这个要求也不难，我们只要把 <code>handle()</code> 的主要代码封装在 <code>setTimeout</code> 里面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    deferred = handler;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... as before</span></span><br><span class="line">  &#125;, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，真正的 promise 库并不倾向使用 <code>setTimeout</code>。如果是面向 NodeJS 的库，它倾向使用 <code>process.nextTick</code>，如果是针对浏览器的，可能用 <code>setImmediate</code> 或者 <a href="https://github.com/NobleJS/setImmediate" target="_blank" rel="noopener">setImmediate shim</a> (目前只有 IE 支持 setImmediate)，又或者是 Kris Kowal 的异步工具库 <a href="https://github.com/kriskowal/asap" target="_blank" rel="noopener">asap</a>（Kris Kowal 还写了 <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q</a> ，一个很受欢迎的 promise 库）</p>
<h3 id="为什么-Promises-A-规范要求异步？"><a href="#为什么-Promises-A-规范要求异步？" class="headerlink" title="为什么 Promises/A+ 规范要求异步？"></a><a name="为什么Promises/A+规范要求异步">为什么 Promises/A+ 规范要求异步？</a></h3><p>因为这样可以保证代码在执行过程保持一致，并且更加可靠，请看下面例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = doAnOperation();</span><br><span class="line">invokeSomething();</span><br><span class="line">promise.then(wrapItAllUp);</span><br><span class="line">invokeSomethingElse();</span><br></pre></td></tr></table></figure></p>
<p>这段代码程序调用的流程是怎样的？从字面理解，你可能认为是 <code>invokeSomething()</code> -&gt; <code>invokeSomethingElse()</code> -&gt; <code>wrapItAllUp()</code>。实际上却是取决于 promise 的 resolve 是同步还是异步的。如果 <code>doAnOperation()</code> 是异步的，流程和预想的一样。但是，如果 <code>doAnOperation()</code> 是同步的，流程就会变成：<code>invokeSomething()</code> -&gt; <code>wrapItAllUp()</code> -&gt; <code>invokeSomethingElse()</code>，这样就不好了。</p>
<p>为了避开这种情况，promise 必须异步地 resolve，即使是你并不需要。这样会减少意外发生，别人在使用 promise 的时候也不用考虑同步还是异步。</p>
<blockquote>
<blockquote>
</blockquote>
<p>Promises always require at least one more iteration of the event loop to resolve. This is not necessarily true of the standard callback approach.</p>
<blockquote>
</blockquote>
</blockquote>
<h2 id="准备封装-then-promise-之前"><a href="#准备封装-then-promise-之前" class="headerlink" title="准备封装 then/promise 之前"></a><a name="准备封装then/promise之前">准备封装 then/promise 之前</a></h2><p>目前市面上已经有许多特性齐全的 promise 库。<a href="https://github.com/then" target="_blank" rel="noopener">then</a> 组织的 promise 库是最简单的。它的目的就是，以最简省的方法实现一个符合 Promises/A+ 规范的 promise 库，如果你看看它的实现方法，会发现看起来很眼熟。</p>
<blockquote>
<blockquote>
<p>本文完成时，最终的 promise 版本看起来就很像 then/promise 的版本。以后可能就不像了，因为它们正推到重写 promise 实现方法。</p>
</blockquote>
</blockquote>
<p>本文的 promise 版本和实际的 promise 库有些不同，因为有许多 Promises/A+ 规范里的细节我并没有涉及。我建议阅读 Promises/A+ 规范，它很简短，而且通俗直白。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果你看到这，真要谢谢你花时间的读下来了。我们已经触及到 promises 的核心，这也是Promises/A+ 规范唯一提及的内容。大部分的 promise 实现方法会提供更多功能，比如 <code>all()</code>, <code>spread()</code>, <code>race()</code>, <code>denodeify()</code> 等待。我建议阅读 [API docs for Bluebird] 了解更多关于 promise 的内容。</p>
<p>当我理解了 promise 的工作原理和注意事项后，我更喜欢它了，它让我的代码变得更加整洁、优雅。它还有许多可以谈论的话题，本文只是抛砖引玉。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>更多关于 promises 的文章  </p>
<ul>
<li><a href="promisejs.org">promisejs.org</a> – great tutorial on promises (already mentioned it a few times)</li>
<li><a href="Q’s Design Rationale">Q’s Design Rationale</a> – an article much like this one, but goes into even more detail. By Kris Kowal, creator of Q</li>
<li><a href="https://github.com/domenic/promises-unwrapping/issues/19" target="_blank" rel="noopener">Some debate over whether done() is a good thing</a></li>
<li><a href="http://solutionoptimist.com/2013/12/27/javascript-promise-chains-2/" target="_blank" rel="noopener">Flattening Promise Chains</a> by Thomas Burleson. A nice article that goes into more advanced usage of promises. If my article is the “what”, then Thomas’s is a nice look at the “why”.</li>
</ul>
<p><strong>Found a mistake?</strong> if I made an error and you want to let me know, please <a href="matt.e.greer@gmail.com">email me</a> or <a href="https://github.com/city41/blog/issues" target="_blank" rel="noopener">file an issue</a>. Thanks!</p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><ul>
<li><a href="http://p-baleine.hatenablog.com/entry/2014/03/12/190000" target="_blank" rel="noopener">日文翻译</a>, translated by Junpei Tajima</li>
<li><a href="http://p-baleine.hatenablog.com/entry/2014/03/12/190000" target="_blank" rel="noopener">繁体中文翻译</a>, translated by Jih-Chi Lee</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/12/2017-09-26-gitolite-installation-and-setup-on-ubuntu-16-04-lts/" rel="next" title="在 ubuntu 搭建基于 Gitolite 的 Git 服务器">
                <i class="fa fa-chevron-left"></i> 在 ubuntu 搭建基于 Gitolite 的 Git 服务器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/12/2017-09-28-how-to-build-private-repo-server-for-android-source-code/" rel="prev" title="搭建支持 Repo 的 Android 源码镜像（Repo 服务器）">
                搭建支持 Repo 的 Android 源码镜像（Repo 服务器） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ttimehc</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#更新日志"><span class="nav-number">1.</span> <span class="nav-text">更新日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">2.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么"><span class="nav-number">3.</span> <span class="nav-text">为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最简单的例子"><span class="nav-number">4.</span> <span class="nav-text">最简单的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-Promise-类型"><span class="nav-number">4.1.</span> <span class="nav-text">定义 Promise 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当前的代码既脆弱又不好"><span class="nav-number">4.2.</span> <span class="nav-text">当前的代码既脆弱又不好</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promises-的状态"><span class="nav-number">5.</span> <span class="nav-text">Promises 的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-Promises链"><span class="nav-number">6.</span> <span class="nav-text">实现 Promises链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回调是可选项"><span class="nav-number">6.1.</span> <span class="nav-text">回调是可选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-Promise-链里返回-Promise-类型"><span class="nav-number">6.2.</span> <span class="nav-text">在 Promise 链里返回 Promise 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promises-的-Reject"><span class="nav-number">7.</span> <span class="nav-text">Promises 的 Reject</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#未知错误应该归纳到-Reject"><span class="nav-number">7.1.</span> <span class="nav-text">未知错误应该归纳到 Reject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promises-可能会“吃掉”错误"><span class="nav-number">7.2.</span> <span class="nav-text">Promises 可能会“吃掉”错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-done-来挽救"><span class="nav-number">7.3.</span> <span class="nav-text">使用 done() 来挽救</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-Reject-中挽救回来"><span class="nav-number">7.4.</span> <span class="nav-text">从 Reject 中挽救回来</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-必须是异步的"><span class="nav-number">8.</span> <span class="nav-text">Promise 必须是异步的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-Promises-A-规范要求异步？"><span class="nav-number">8.1.</span> <span class="nav-text">为什么 Promises/A+ 规范要求异步？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备封装-then-promise-之前"><span class="nav-number">9.</span> <span class="nav-text">准备封装 then/promise 之前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论"><span class="nav-number">10.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸阅读"><span class="nav-number">11.</span> <span class="nav-text">延伸阅读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#翻译"><span class="nav-number">12.</span> <span class="nav-text">翻译</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ttimehc</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  
    <!-- LOCAL: You can save these files to your site and update links -->

  
  <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitmint.browser.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css">
<!-- END LOCAL -->

<script>
  function renderGitment() {
    var gitment = new Gitmint({
      id: window.location.pathname,
      owner: 'chasecs',
      repo: 'chasecs.github.io',
      
        lang: '' || navigator.language || navigator.systemLanguage || navigator.userLanguage,
      
      oauth: {
      
      
        client_secret: '054b7811c14e27f869e637afd14f6f380fa632c1',
      
        client_id: 'eb2224abc6c383a0371e'
      }
    });
    gitment.render('gitment-container');
  }

  
    renderGitment();
  
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
